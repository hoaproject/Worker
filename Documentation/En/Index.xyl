<?xml version="1.0" encoding="utf-8"?>

<overlay xmlns="http://hoa-project.net/xyl/xylophone">
<yield id="chapter">

  <p>Workers frees an application of <strong>heavy</strong> or
  <strong>blocking</strong> tasks. The <code>Hoa\Worker</code> library creates
  and manipulates workers effortlessly.</p>

  <h2 id="Table_of_contents">Table of contents</h2>

  <tableofcontents id="main-toc" />

  <h2 id="Introduction" for="main-toc">Introduction</h2>

  <p>Il est conseillé de lire le chapitre sur
  <a href="@hack:chapter=Zombie"><code>Hoa\Zombie</code></a> dans lequel nous
  apprennons comment transformer un processus en <strong>zombie</strong>. C'est
  l'idée qu'exploite <code>Hoa\Worker</code> pour, une fois le zombie créé,
  mettre en place un <strong>serveur</strong> qui va recevoir des
  <strong>messages</strong>. À chaque message reçu, un
  <strong>événement</strong> va être émis que nous pourrons intercepter pour
  exécuter une <strong>tâche</strong>.</p>
  <p>Ces tâches peuvent être de plusieurs natures comme envoyer une notification
  (par exemple par mail), faire des opérations importantes sur des bases de
  données, traiter de multiples fichiers etc. L'idée est de
  <strong>décharger</strong> l'application de tâches qui pourraient la
  <strong>ralentir</strong> et s'exécuter en <strong>parallèle</strong> sans
  interférer avec l'exécution de l'application.</p>
  <p>Même si le protocole établi permet une certaine <strong>intégrité</strong>
  et <strong>sûreté</strong> des messages, il est préférables que les
  communications se déroulent de <strong>serveur à serveur</strong> et non pas
  transitées par le client.</p>
  <p><code>Hoa\Worker</code> is made of two parts :</p>
  <ul>
    <li><code>Hoa\Worker\Backend\Shared</code> to
    <strong>create</strong> a <strong>shared</strong> worker
    between <strong>many</strong> processes ;</li>
    <li><code>Hoa\Worker\Shared</code> to <strong>send</strong> messages to
    the worker.</li>
  </ul>

  <h2 id="Shared_workers" for="main-toc">Shared workers</h2>

  <p>A worker is primarily <strong>identified</strong> by
  a <code>workerId</code>, sometime abbreviated <code>wid</code>. This identifier
  is used to create a <strong>profile</strong> for our worker thanks to
  <code>Hoa\Worker\Run</code> that does only this.
  Only an identifier and the server address created in the worker are required
  to establish a profile. Ensuite,
  nous pourrons démarrer un worker uniquement à partir de son identifiant.</p>
  <p>La première étape va donc être de vérifier que le profil existe grâce à la
  méthode <code>Hoa\Worker\Run::widExists</code>, dans le cas échant nous
  allons le créer avec la méthode <code>Hoa\Worker\Run::register</code>.
  Ainsi :</p>
  <pre><code class="language-php">if (false === Hoa\Worker\Run::widExists('demorker')) {
    Hoa\Worker\Run::register('demorker', 'tcp://127.0.0.1:123456');
}</code></pre>
  <p>Nous sommes maintenant certains que le profil existe. Nous pouvons alors
  <strong>démarrer</strong> notre worker. Pour cela, nous
  devons utiliser son <strong>identifiant</strong> et son <strong>mot de
  passe</strong> (nécessaire pour l'arrêter) dans le constructeur de
  <code>Hoa\Worker\Backend\Shared</code>. Une fois l'objet créé, il émettra une
  seule catégorie d'<strong>événement</strong> : <code>message</code>, que nous
  allons écouter pour mettre en place notre propre <strong>protocole</strong> de
  traitement de tâches. Enfin, la méthode
  <code>Hoa\Worker\Backend\Shared::run</code> permet de démarrer le worker :</p>
  <pre><code class="language-php">$file   = new Hoa\File\Write(__DIR__ . DS . 'Log');
$worker = new Hoa\Worker\Backend\Shared('demorker', 'iamapassword');
$worker->on('message', function (Hoa\Core\Event\Bucket $bucket) use ($file) {
    // compute messages.
    $data = $bucket->getData();
    $file->writeAll($data['message'] . "\n");
});
$worker->run();
</code></pre>
  <p>We are <strong>free</strong> to do what we want to process the
  <strong>task</strong> !  The format is completely free : binary, compressed,
  command line, serialized object… we can send what we want.</p>

  <h3 id="Where_are_the_wid_profiles_stored" for="main-toc">Where are the
  <code>wid</code> profiles stored ?</h3>

  <p>The workers profiles are stored in the
  <code>hoa://Data/Variable/Run/<em>workerId</em>.wid</code> files. Attention à
  vérifier que ce chemin est bien défini, par exemple en choisissant le dossier
  <code>/path/to/wid/directory</code> :</p>
  <pre><code class="language-php">Hoa\Core\Core::getInstance()->setProtocol(
    'hoa://Data/Variable/Run',
    '/path/to/wid/directory'
);
var_dump(resolve('hoa://Data/Variable/Run'));

/**
 * Will output:
 *     string(21) "/path/to/wid/directory
 */</code></pre>
  <p>Notons que si nous utilisons Hoa avec son dossier <code>Data/</code> alors
  <code>hoa://Data/</code> se définira <strong>automatiquement</strong> vers ce
  dossier et nous n'aurons pas besoin de redéfinir le protocole. Et dans tous
  les cas, il ne sera <strong>pas nécessaire</strong> de modifier le code mais
  uniquement le protocole <code>hoa://</code>.</p>

  <h2 id="Communicate_with_a_worker" for="main-toc">Communicate with a worker</h2>

  <p>Un worker représente un serveur, nous allons donc
  présenter son <strong>client</strong> qui permet de lui
  <strong>envoyer</strong> des tâches. Le client est très simple à utiliser, il
  suffit d'instancier la classe <code>Hoa\Worker\Shared</code> en précisant
  l'identifiant du worker, et ensuite utiliser la méthode
  adéquate pour envoyer des messages, à savoir
  <code>Hoa\Worker\Shared::postMessage</code> :</p>
  <pre><code class="language-php">$worker = new Hoa\Worker\Shared('demorker');
$worker->postMessage('mail gordon@freeman.hl Hello Gordon!');</code></pre>
  <p>Bien sûr, le client va chercher le profil du worker dans
  le fichier <code>hoa://Data/Variable/Run/<em>workerId</em>.wid</code>. Si nous
  l'avons redéfini dans le worker, il faudra aussi le
  redéfinir dans son client.</p>
  <p>Nous pouvons utiliser la méthode
  <code>Hoa\Worker\Shared::postMessage</code> autant de fois que nous le
  désirons mais attention, elle se connecte et se déconnecte <strong>à chaque
  fois</strong> du worker pour ne pas perturber l'exécution
  de notre application principale. Il faut alors penser à envoyer le
  <strong>maximum</strong> d'informations à chaque fois (par exemple à travers
  un tableau, les données seront sérialisées dans tous les cas).</p>

  <h2 id="Use_dedicated_commands" for="main-toc">Use dedicated commands</h2>

  <p>Pour exécuter un worker, il faut avant tout démarrer
  <a href="http://php.net/install.fpm">PHP FPM</a> :</p>
  <pre><code class="language-shell">$ php-fpm -d listen=127.0.0.1:9000</code></pre>
  <p>Ensuite, pour <strong>démarrer</strong> notre worker,
  nous allons utiliser Hoa en ligne de commande, et plus particulièrement la
  commande <code>worker:start</code>. Elle n'est qu'un alias pratique vers
  <code>Hoa\Worker\Backend\Shared::start</code> qui nécessite l'adresse de
  PHP FPM (par défaut <code>127.0.0.1:9000</code>) et le chemin vers le fichier
  qui contient notre worker :</p>
  <pre><code class="language-shell">$ hoa worker:start /path/to/your/worker.php</code></pre>
  <p>Pour vérifier que notre worker a été créé, nous pouvons
  utiliser la commande <code>worker:status</code> qui va nous retourner la
  <strong>liste</strong> de tous les workers ainsi que des
  <strong>informations</strong> et <strong>statistiques</strong> associées comme
  les identifiants, adresses des serveurs, âge, consommation mémoire actuelle,
  moyenne et maximum etc. En réalité, elle n'est qu'un alias vers
  <code>Hoa\Worker\Shared::getInformations()</code>. Ainsi :</p>
  <pre><code class="language-shell">$ hoa worker:status --run /path/to/wid/directory/
Shared worker informations

ID        PID   Socket                  Uptime      Messages  Last
demorker  2465  tcp://127.0.0.1:123456  0d00:03:15  0         -

demorker  ||||||||||||||||||||||||||||||||||||   |  1,398Kb 1,398Kb 1,536Kb

1 shared worker is running.</code></pre>
  <p>Note : le code couleur n'apparaît pas dans l'exemple.</p>
  <p>Notre worker est maintenant en place. Nous pouvons
  <strong>exécuter</strong> le client sans problème (en ligne de commande,
  <em>via</em> un navigateur, peu importe) !</p>
  <p>Enfin, pour <strong>arrêter</strong> le worker
  proprement, nous avons la commande <code>worker:stop</code>, qui n'est qu'un
  alias de <code>Hoa\Worker\Backend\Shared</code>, nécessitant l'identifiant du
  worker et son <strong>mot de passe</strong> :</p>
  <pre><code class="language-shell">$ hoa worker:stop --run /path/to/wid/directory/ demorker
Password: ▋</code></pre>
  <p>If password is correct, the worker will be stopped and the client won't be
  able to communicate with it and will throw a
  <code>Hoa\Worker\Exception</code> exception.</p>

  <h2 id="Conclusion" for="main-toc">Conclusion</h2>

  <p><code>Hoa\Worker</code> ia a demonstration of what it is possible to build
  with <a href="@hack:chapter=Zombie"><code>Hoa\Zombie</code></a> but not only.
  Il remplit parfaitement son rôle à savoir
  <strong>décharger</strong> l'application de traitements
  <strong>lourds</strong> et <strong>bloquants</strong>. Les commandes
  <code>worker:<em>*</em></code> permettent d'<strong>administrer</strong> ces
  workers à moindre efforts. Rien ne vous empêche de bâtir
  votre <strong>propre</strong> solution à partir des concepts évoqués ici !</p>

</yield>
</overlay>
